@inject UsersHttpClient UsersHttpClient
@inject StoresHttpClient StoresHttpClient
@using Data.Models.Users

<ModalBody>

    @* <h3>@userModalDetails.Header</h3>
                <p>@userModalDetails.Description</p> *@
    <label class="w-100 d-flex">
        First Name:
        <InputText class="flex-grow-1" type="Text" @bind-value="AddUpdateUserModel!.FIRST_NAME" />
        <div class="text-danger">
            <ValidationMessage For=@(() => AddUpdateUserModel.FIRST_NAME) />
        </div>
    </label>
    <label class="w-100 d-flex">
        Last Name:
        <InputText class="flex-grow-1" type="Text" @bind-value="AddUpdateUserModel!.LAST_NAME" />
        <div class="text-danger">
            <ValidationMessage For=@(() => AddUpdateUserModel.LAST_NAME) />
        </div>
    </label>

    <label class="w-100 d-flex">
        Email:
        <InputText class="flex-grow-1" type="Text" @bind-value="AddUpdateUserModel!.EMAIL" />
        <div class="text-danger">
            <ValidationMessage For=@(() => AddUpdateUserModel.EMAIL) />
        </div>
    </label>

    <label>
        Role:
        <InputSelect @bind-value="AddUpdateUserModel!.ROLE_NAME">
            <option value="Owner">Owner</option>
            <option value="Manager">Manager</option>
            <option value="Employee">Employee</option>
        </InputSelect>
        <div class="text-danger">
            <ValidationMessage For=@(() => AddUpdateUserModel.ROLE_NAME) />
        </div>
    </label>

    @* TODO: Store selection *@

    @* Store Selection *@

    <p id="StoreSelectHeader">Store Selection</p>

    <p>To select multiple stores use Ctrl-click</p>

    <label>
        Available Stores:
        <select size="6" multiple @onchange="HandleSelectionFromNotUserStores">
            @if (notUserStores != null)
            {
                @foreach (var store in notUserStores)
                {
                    <option value="@store.TUID">@store.NAME</option>
                }
            }
        </select>
        <Button Variant="primary" TextAlignment="center" @onclick="SelectStoresForUser">
            Select Store
        </Button>

    </label>

    <label>
        Selected Stores:
        <select size="6" multiple @onchange="HandleSelectionFromUserStores">
            @if (userStores != null)
            {
                @foreach (var store in userStores)
                {
                    <option value="@store.TUID">@store.NAME</option>
                }
            }
        </select>
        <Button Variant="primary" TextAlignment="center" @onclick="RemoveStoresFromUser">
            Remove Store
        </Button>
    </label>

</ModalBody>

@code {

    [Parameter] public Data.Models.Users.UpdatePublicInfoUser? AddUpdateUserModel { get; set; } = new();

    [Parameter] public List<Data.Models.Users.AddUserToStoreRequest>? AddUpdateUserStoreRequestModels { get; set; }

    [Parameter] public List<Data.Models.Stores.Store>? userStores { get; set; }

    [Parameter] public List<Data.Models.Stores.Store>? notUserStores { get; set; }

    public List<int> selectedNotUserStoreTUIDs { get; set; } = new();
    public List<int> selectedUserStoreTUIDs { get; set; } = new();

    [Parameter] public required EventCallback UpdateUsers { get; set; }

    public void SelectStoresForUser()
    {

        var storesToMove = notUserStores?.Where(store => selectedNotUserStoreTUIDs.Contains(store.TUID)).ToList();
        if (storesToMove == null) { Console.WriteLine("No stores to move"); return; }

        foreach (var store in storesToMove)
        {
            Console.WriteLine(store.NAME);
            userStores?.Add(store);
            notUserStores?.Remove(store);

        }
        selectedNotUserStoreTUIDs.Clear();

        StateHasChanged();
    }

    public void RemoveStoresFromUser()
    {
        var storesToMove = userStores?.Where(store => selectedUserStoreTUIDs.Contains(store.TUID)).ToList();
        if (storesToMove == null) return;

        foreach (var store in storesToMove)
        {
            notUserStores?.Add(store);
            userStores?.Remove(store);
        }

        selectedUserStoreTUIDs.Clear();

        StateHasChanged();

    }

    public void HandleSelectionFromUserStores(ChangeEventArgs e)
    {
        selectedUserStoreTUIDs = ExtractSelectedIds(e);
    }

    public void HandleSelectionFromNotUserStores(ChangeEventArgs e)
    {
        selectedNotUserStoreTUIDs = ExtractSelectedIds(e);
    }

    private List<int> ExtractSelectedIds(ChangeEventArgs e)
    {
        var selected = new List<int>();
        if (e.Value is IEnumerable<object> values)
        {
            foreach (var v in values)
            {
                if (int.TryParse(v?.ToString(), out var id))
                    selected.Add(id);
            }
        }
        return selected;
    }

    /* Newly added */
    public void ResetUserStoreModel(int userTUID)
    {
        if (AddUpdateUserStoreRequestModels != null)
        {
            // Clear the model
            AddUpdateUserStoreRequestModels!.Clear();

            // Add current store access
            foreach (var store in userStores!)
            {
                AddUpdateUserStoreRequestModels!.Add(new Data.Models.Users.AddUserToStoreRequest
                {
                    USER_TUID = userTUID,
                    STORE_TUID = store.TUID
                });
            }
        }
    }

    public async Task UpdateUser(int userTUID)
    {
        if (AddUpdateUserModel != null)
        {
            var response = await UsersHttpClient.UpdateUserPublicInfo(userTUID, AddUpdateUserModel!);
        }

    }

    public async Task UpdateUserStores(int userTUID)
    {
        Console.WriteLine("Updating stores for user of tuid " + userTUID);
        // Updates user store access
        var storeTUIDs = (AddUpdateUserStoreRequestModels ?? new List<AddUserToStoreRequest>())
        .Select(store => store.STORE_TUID)
        .ToList();

        foreach (var storeTUID in storeTUIDs)
        {
            Console.WriteLine(storeTUID);
        }

        var request = new UpdateAccessListRequest
        {
            USER_TUID = userTUID,
            STORE_TUIDS = storeTUIDs
        };

        var response = await UsersHttpClient.UpdateAccessList(request);

    }

    public async Task InitUserStores(int userTUID)
    {
        // Initialize the stores for the user
        if (userTUID != 0)
        {
            await InitUserStoresAssigned(userTUID);

            await InitUsersStoresNotAssigned(userTUID);
        }
        else
        {
            // Initializes all stores for unassigned and none for assigned
            await InitUsersStoresNotAssigned(userTUID);

        }

    }

    private async Task InitUserStoresAssigned(int userTUID)
    {
        if (userTUID == 0)
        {
            userStores = new List<Data.Models.Stores.Store>();
        }
        else
        {
            var response = await UsersHttpClient.GetStoreOfUserById(userTUID);

            if (response != null)
            {
                userStores = response.ToList();
            }


        }

        StateHasChanged();
    }

    private async Task InitUsersStoresNotAssigned(int userId)
    {
        if (userId != 0)
        {
            var response = await UsersHttpClient.GetStoresNotForUser(userId);

            //Console.WriteLine("Dashboard handling response for stores NOT assigned as:");
            //Console.WriteLine(response);

            if (response != null)
            {

                notUserStores = response.ToList();
            }


        }
        else
        {
            // New user - Fill available stores list
            notUserStores = await StoresHttpClient.GetListOfStores();
        }

        StateHasChanged();
    }

    public void ClearAddUpdateUserModel(int userTUID)
    {
        AddUpdateUserModel = new();
        ResetUserStoreModel(userTUID);
    }

}