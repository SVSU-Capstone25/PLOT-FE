@inject StoresHttpClient StoresHttpClient
@inject UsersHttpClient UsersHttpClient
@inject IJSRuntime JS

<Modal class="modal-dialog modal-xl user-modal user-info-modal" SizeClass="modal-xl" Backdrop="static" Keyboard="false"
    @attributes="Attributes">
    <ModalHeader Title="Update User" />

    <EditForm Model="UpdateUserModel" OnValidSubmit="() => OnUpdateUserSubmit()">
        <DataAnnotationsValidator />

        <AddUpdateUserModalBody AddUpdateUserModel="UpdateUserModel" AssignedStores="UpdateUserStores"
            UnassignedStores="NotUpdateUserStores" SignalParentAssignedStoresChanged="HandleUserStoresChange"
            SignalParentUnassignedStoresChanged="HandleNotUserStoresChange" OnInit="HandleBodyInit"
            DisableSubmitInParent="DisableSubmitFromChild" @ref="modalBodyRef" />

        <ModalFooter OnCancelClick="ClearUpdateUserModel">
            <Button Variant="primary" TextAlignment="center" type="submit" data-bs-dismiss="modal"
                disabled="@IsSubmitDisabled">
                Submit
            </Button>
        </ModalFooter>

    </EditForm>

</Modal>

@code {

    // Parameters
    [Parameter(CaptureUnmatchedValues = true)] public required Dictionary<string, object> Attributes { get; set; }

    // Model used for updating information on user first name, last name, email, and role in the database
    [SupplyParameterFromForm] private Data.Models.Users.UpdatePublicInfoUser? UpdateUserModel { get; set; }

    // Model representing the user
    [Parameter] public required Data.Models.Users.UserDTO? User { get; set; }

    // Update Users callback for rerendering UserDashboard in UserDashboard.razor file
    [Parameter] public required EventCallback UpdateUsers { get; set; }

    private bool modalBodyInit = false;

    private bool IsSubmitDisabled = false;

    public List<Data.Models.Stores.Store>? UpdateUserStores = new();

    public List<Data.Models.Stores.Store>? NotUpdateUserStores = new();

    public AddUpdateUserModalBody? modalBodyRef;

    public Data.Models.Users.UpdatePublicInfoUser? AddUpdateUserModel = new();

    // List of store models
    public List<Data.Models.Stores.Store> userStores = new();

    public List<Data.Models.Stores.Store> notUserStores = new();

    // Lists of TUIDs for stores
    // TODO: Why are these separate from the models?
    public List<int> selectedNotUserStoreTUIDs = new();

    public List<int> selectedUserStoreTUIDs = new();

    protected override void OnInitialized()
    {
        // Iniitalize model used for updating the user's public info
        // with user's information
        UpdateUserModel ??= new Data.Models.Users.UpdatePublicInfoUser
        {
            FIRST_NAME = User!.FIRST_NAME,
            LAST_NAME = User!.LAST_NAME,
            EMAIL = User!.EMAIL,
            ROLE_NAME = User!.ROLE
        };

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Ensure that when stores are initialized, the modal body
        // has been rendered.
        // Otherwise, modals will sometimes render with empty
        // store selection boxes
        if (!modalBodyInit)
        {
            if (modalBodyRef != null)
            {
                await modalBodyRef!.InitUserStores(User!.TUID);
                modalBodyInit = true;
            }
        }
    }

    public void HandleBodyInit()
    {

        if (modalBodyRef != null)
        {
            modalBodyRef.StateHasChangedFromParent();
        }

        StateHasChanged();
    }

    /*
    private void OnUpdateUserSubmit()
    {
    _ = Task.Run(async () =>
    {
    try
    {
    // Perform database update logic here
    await OnUpdateUserSubmitStuff();
    }
    catch (Exception ex)
    {
    // Log the exception or handle it in a way that's appropriate for your app
    Console.WriteLine($"Error: {ex.Message}");
    }
    });
    }
    */

    public async Task OnUpdateUserSubmit()
    {
        await UsersHttpClient.UpdateUserPublicInfo(User!.TUID, UpdateUserModel!);
        if (UpdateUserStores != null)
        {
            await UsersHttpClient.UpdateAccessList(new Data.Models.Users.UpdateAccessListRequest
            {
                USER_TUID = User!.TUID,
                STORE_TUIDS = UpdateUserStores.Select(store => store.TUID)
            });
        }
        await UpdateUsers.InvokeAsync();
    }

    @*Done: Update user parameters: Adapt suggestion: UserDTO user, List<int> storeIds*@
    @*To Do: Traceback, UserDTO and StoreTUIDs to determine which should go in each parameter
    But First: Should I look at UpdatePublicInfoUser to make sure it's correct?
    *@
    @*
    public async Task<bool> UpdateUser(Data.Models.Users.UserDTO? UserDTO, Data.Models.Users.UpdatePublicInfoUser
    StoreTUIDs)
    {
        //IsSubmitDisabled = true;

        //StateHasChanged();

        //TODO: Make EventCallbacks
        //await ShowLoadingModal.InvokeAsync(UpdateUserSubmitMessage);
        await modalBodyRef!.UpdateUser(UserDTO!.TUID);
        await modalBodyRef!.UpdateUserStores(StoreTUIDs);
        //await HideLoadingModal.InvokeAsync();
        await UpdateUsers.InvokeAsync();


        //await ClearUpdateUserModel();
    }
*@

    public void ClearUpdateUserModel()
    {
        //ShowHide=Hide;
        //await JS.InvokeVoidAsync("eval", $"$('#update-user-modal-{User!.TUID}').modal('hide')");

        Console.WriteLine("about to hide id of:");
        Console.WriteLine($"#update-user-modal-{User!.TUID}");

        //await JS.InvokeVoidAsync("hideModal", $"#update-user-modal-{User!.TUID}");
        //ShowHide = Hide;

        if (modalBodyRef != null)
        {
            modalBodyRef.StateHasChangedFromParent();
        }
        else
        {
            Console.WriteLine("How the heck can modalBodyRef be null here?");
        }

        //IsSubmitDisabled = false;

        //await JS.InvokeVoidAsync("hideModal", $"#update-user-modal-{User!.TUID}");
        StateHasChanged();

    }

    public void HandleUserStoresChange(List<Data.Models.Stores.Store>? NewUpdateUserStores)
    {
        UpdateUserStores = NewUpdateUserStores;
    }

    public void HandleNotUserStoresChange(List<Data.Models.Stores.Store>? NewNotUpdateUserStores)
    {
        NotUpdateUserStores = NewNotUpdateUserStores;
    }

    public void DisableSubmitFromChild(bool isDisabled)
    {
        IsSubmitDisabled = isDisabled;
    }

}